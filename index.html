<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dimensional Maze</title>
  <style>
    body { margin:0; overflow:hidden; background:#222; color:#fff; font-family:sans-serif; }
    #ui { position:absolute; top:10px; left:10px; z-index:10; }
    canvas, #view3d { position:absolute; top:0; left:0; }
    #view3d, #view1d, #view2d { display:none; }
  </style>
</head>
<body>
  <div id="ui">You are a <span id="dimLabel">2D Square</span></div>
  <canvas id="view2d"></canvas>
  <canvas id="view1d"></canvas>
  <div id="view3d"></div>

  <!-- include Three.js for 3D mode -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  // --- Configuration ---
  const COLS = 15, ROWS = 15, CELL2D = 40;
  const DOOR_X = COLS - 1, DOOR_Y = ROWS - 1;
  const CORRIDOR_LEN = COLS, DOOR1_POS = CORRIDOR_LEN - 1;

  // --- DOM & contexts ---
  const dimLabel = document.getElementById('dimLabel');
  const view2d = document.getElementById('view2d');
  const view1d = document.getElementById('view1d');
  const view3d = document.getElementById('view3d');
  const ctx2 = view2d.getContext('2d');
  const ctx1 = view1d.getContext('2d');

  // --- Maze data & player ---
  let grid = [], player2 = {x:0,y:0}, pos1D = 0;
  let dimension = 2;

  // --- Maze generation (DFS) ---
  function genMaze() {
    let g = [];
    for(let x=0;x<COLS;x++){
      g[x]=[];
      for(let y=0;y<ROWS;y++){
        g[x][y]={x,y, walls:{top:true,right:true,bottom:true,left:true}, visited:false};
      }
    }
    let stack=[g[0][0]]; g[0][0].visited=true;
    while(stack.length){
      let current = stack[stack.length-1];
      let {x,y}=current;
      let neighbors = [];
      if(y>0 && !g[x][y-1].visited) neighbors.push(g[x][y-1]);
      if(x<COLS-1 && !g[x+1][y].visited) neighbors.push(g[x+1][y]);
      if(y<ROWS-1 && !g[x][y+1].visited) neighbors.push(g[x][y+1]);
      if(x>0 && !g[x-1][y].visited) neighbors.push(g[x-1][y]);
      if(neighbors.length){
        let next = neighbors[Math.floor(Math.random()*neighbors.length)];
        // remove walls
        if(next.x===x){
          if(next.y<y){ current.walls.top=false; next.walls.bottom=false; }
          else{ current.walls.bottom=false; next.walls.top=false; }
        } else {
          if(next.x<x){ current.walls.left=false; next.walls.right=false; }
          else{ current.walls.right=false; next.walls.left=false; }
        }
        next.visited=true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }
    return g;
  }

  // --- 2D drawing ---
  view2d.width = COLS*CELL2D;
  view2d.height = ROWS*CELL2D;
  function draw2D() {
    ctx2.fillStyle='#222'; ctx2.fillRect(0,0,view2d.width,view2d.height);
    ctx2.strokeStyle='#fff'; ctx2.lineWidth=2;
    for(let x=0;x<COLS;x++) for(let y=0;y<ROWS;y++){
      let cell = grid[x][y];
      let X = x*CELL2D, Y = y*CELL2D;
      if(cell.walls.top){ ctx2.beginPath(); ctx2.moveTo(X,Y); ctx2.lineTo(X+CELL2D,Y); ctx2.stroke(); }
      if(cell.walls.right){ ctx2.beginPath(); ctx2.moveTo(X+CELL2D,Y); ctx2.lineTo(X+CELL2D,Y+CELL2D); ctx2.stroke(); }
      if(cell.walls.bottom){ ctx2.beginPath(); ctx2.moveTo(X+CELL2D,Y+CELL2D); ctx2.lineTo(X,Y+CELL2D); ctx2.stroke(); }
      if(cell.walls.left){ ctx2.beginPath(); ctx2.moveTo(X,Y+CELL2D); ctx2.lineTo(X,Y); ctx2.stroke(); }
    }
    // portal cell
    ctx2.fillStyle='lime';
    ctx2.fillRect(DOOR_X*CELL2D+8, DOOR_Y*CELL2D+8, CELL2D-16, CELL2D-16);
    // player
    ctx2.fillStyle='cyan';
    ctx2.fillRect(player2.x*CELL2D+CELL2D/4, player2.y*CELL2D+CELL2D/4, CELL2D/2, CELL2D/2);
  }

  // --- 1D drawing ---
  view1d.width = CORRIDOR_LEN*CELL2D;
  view1d.height = 100;
  function draw1D() {
    ctx1.fillStyle='#222'; ctx1.fillRect(0,0,view1d.width,view1d.height);
    ctx1.strokeStyle='#fff'; ctx1.lineWidth=2;
    // corridor line
    ctx1.beginPath(); ctx1.moveTo(0,50); ctx1.lineTo(view1d.width,50); ctx1.stroke();
    // markers
    for(let i=0;i<=CORRIDOR_LEN;i++){
      let x=i*CELL2D;
      ctx1.beginPath(); ctx1.moveTo(x,40); ctx1.lineTo(x,60); ctx1.stroke();
    }
    // portal at end
    let doorX = DOOR1_POS*CELL2D + (CELL2D-40)/2;
    ctx1.fillStyle='orange';
    ctx1.fillRect(doorX,10,40,40);
    // player = vertical segment
    ctx1.strokeStyle='cyan'; ctx1.lineWidth=4;
    let px = pos1D*CELL2D + CELL2D/2;
    ctx1.beginPath(); ctx1.moveTo(px,35); ctx1.lineTo(px,65); ctx1.stroke();
  }

  // --- 3D init ---
  let scene, camera, renderer, playerMesh, move3d={forward:0,back:0,left:0,right:0};
  function init3D() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x222222);
    camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,1,1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth,window.innerHeight);
    view3d.appendChild(renderer.domElement);
    // lights
    scene.add(new THREE.AmbientLight(0xcccccc,0.5));
    let dl = new THREE.DirectionalLight(0xffffff,0.8);
    dl.position.set(1,2,1).normalize();
    scene.add(dl);
    // floor
    let floor = new THREE.PlaneGeometry(COLS*10,ROWS*10);
    let fm = new THREE.MeshStandardMaterial({color:0x333333});
    let fp = new THREE.Mesh(floor,fm);
    fp.rotation.x = -Math.PI/2; scene.add(fp);
    // walls
    let wallH = 10;
    grid.forEach(col => col.forEach(cell => {
      let x = cell.x*10, z = cell.y*10;
      if(cell.walls.top){
        let geo = new THREE.BoxGeometry(10,wallH,1);
        let m = new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0xffffff}));
        m.position.set(x+5,wallH/2,z);
        scene.add(m);
      }
      if(cell.walls.right){
        let geo = new THREE.BoxGeometry(1,wallH,10);
        let m = new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0xffffff}));
        m.position.set(x+10,wallH/2,z+5);
        scene.add(m);
      }
      if(cell.walls.bottom){
        let geo = new THREE.BoxGeometry(10,wallH,1);
        let m = new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0xffffff}));
        m.position.set(x+5,wallH/2,z+10);
        scene.add(m);
      }
      if(cell.walls.left){
        let geo = new THREE.BoxGeometry(1,wallH,10);
        let m = new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0xffffff}));
        m.position.set(x,wallH/2,z+5);
        scene.add(m);
      }
    }));
    // player cube
    let pg = new THREE.BoxGeometry(5,5,5);
    let pm = new THREE.MeshStandardMaterial({color:0x00ffff});
    playerMesh = new THREE.Mesh(pg,pm);
    playerMesh.position.set(player2.x*10+5,2.5,player2.y*10+5);
    scene.add(playerMesh);
    camera.position.set(playerMesh.position.x,8,playerMesh.position.z+12);
    camera.lookAt(playerMesh.position);

    // movement controls
    document.addEventListener('keydown',e=>{
      if(dimension!==3) return;
      if(e.key==='ArrowUp') move3d.forward=1;
      if(e.key==='ArrowDown') move3d.back=1;
      if(e.key==='ArrowLeft') move3d.left=1;
      if(e.key==='ArrowRight') move3d.right=1;
    });
    document.addEventListener('keyup',e=>{
      if(dimension!==3) return;
      if(e.key==='ArrowUp') move3d.forward=0;
      if(e.key==='ArrowDown') move3d.back=0;
      if(e.key==='ArrowLeft') move3d.left=0;
      if(e.key==='ArrowRight') move3d.right=0;
    });

    function animate(){
      requestAnimationFrame(animate);
      let speed=0.2;
      if(move3d.forward) playerMesh.position.z -= speed;
      if(move3d.back)    playerMesh.position.z += speed;
      if(move3d.left)    playerMesh.position.x -= speed;
      if(move3d.right)   playerMesh.position.x += speed;
      camera.position.set(playerMesh.position.x,8,playerMesh.position.z+12);
      camera.lookAt(playerMesh.position);
      renderer.render(scene,camera);
    }
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
    animate();
  }

  // --- switch modes ---
  function setDimension(d){
    dimension = d;
    view2d.style.display = d===2 ? 'block':'none';
    view1d.style.display = d===1 ? 'block':'none';
    view3d.style.display = d===3 ? 'block':'none';
    if(d===2){ dimLabel.innerText='2D Square'; draw2D(); }
    if(d===1){ dimLabel.innerText='1D Line'; draw1D(); }
    if(d===3){ dimLabel.innerText='3D Cube'; init3D(); }
  }

  // --- input for 2D & 1D ---
  document.addEventListener('keydown', e=>{
    if(dimension===2){
      let c = grid[player2.x][player2.y];
      if(e.key==='ArrowUp'   && !c.walls.top)    player2.y--;
      if(e.key==='ArrowRight'&& !c.walls.right)  player2.x++;
      if(e.key==='ArrowDown' && !c.walls.bottom) player2.y++;
      if(e.key==='ArrowLeft' && !c.walls.left)   player2.x--;
      draw2D();
      if(player2.x===DOOR_X && player2.y===DOOR_Y) setDimension(1);
    } else if(dimension===1){
      if(e.key==='ArrowLeft' && pos1D>0)      pos1D--;
      if(e.key==='ArrowRight'&& pos1D<DOOR1_POS) pos1D++;
      draw1D();
      if(pos1D===DOOR1_POS) setDimension(3);
    }
  });

  // --- start game ---
  grid = genMaze();
  setDimension(2);
  </script>
</body>
</html>
